use std::num;

use huffman::huffman_tree::TreeNode;
use huffman::huffman_codes::HUFFMAN_CODES;

pub struct HuffmanDecoder {
    tree: ~TreeNode,
}

impl HuffmanDecoder {
    pub fn new() -> HuffmanDecoder {
        let huffman_tree = create_tree();
        HuffmanDecoder {
            tree: huffman_tree,
        }
    }

    pub fn decode(&mut self, bytes: ~[u8]) -> Option<~[u8]> {
        let mut result = ~[];
        let mut subtree = self.tree.clone();

        for byte in bytes.iter() {
            let mut byte = *byte;
            for _ in range(0,8) {
                let bit = 
                    if (byte & 128) > 0 {
                        1
                    } else {
                        0
                    };

                byte <<= 1;

                subtree = 
                    if bit == 1 {
                        match subtree.right {
                            Some(new_subtree) => { 
                                if new_subtree.left == None && new_subtree.right == None {
                                    result.push(new_subtree.code.to_u8().unwrap());

                                    self.tree.clone()
                                } else {
                                    new_subtree
                                }
                            },
                            None => {
                                return None;
                            }
                        }

                    } else {
                        match subtree.left {
                            Some(new_subtree) => { 
                                if new_subtree.right == None && new_subtree.left == None {
                                    result.push(new_subtree.code.to_u8().unwrap());

                                    self.tree.clone()
                                } else {
                                    new_subtree
                                }
                            },
                            None => {
                                return None;
                            }
                        }
                    };
            }
        }

        Some(result)
    }

    
}

fn create_tree() -> ~TreeNode {
    let mut root: ~TreeNode = TreeNode::new_node();

    for i in range(0, HUFFMAN_CODES.len()) {
        let key: uint =  num::from_str_radix(HUFFMAN_CODES[i].clone(), 2).unwrap();
        let new_node: ~TreeNode = ~TreeNode {
            left: None,
            right: None,
            key: key,
            code: i,
        };

        root.add_node(new_node, HUFFMAN_CODES[i].len() - 1);
    }

    root
}

#[test]
fn huffman_decoder_test() {
    let mut decoder = HuffmanDecoder::new();

    let huffman_codes = ~[255, 255, 238, 191, 255, 251, 191, 255, 254, 243, 255, 255, 189, 255, 255, 239, 191, 255, 251, 255, 255, 255, 3, 255, 255, 193, 255, 255, 240, 191, 255, 252, 63, 255, 255, 19, 255, 255, 197, 255, 255, 241, 191, 255, 252, 127, 255,255, 35, 255, 255, 201, 255, 255, 242, 191, 255, 252, 191, 255, 255, 51, 255, 255, 205, 255, 255, 243, 191, 255, 252, 255, 255, 255, 67, 255, 255, 209, 255, 255, 244, 191, 255, 253, 63, 255, 255, 83, 255, 255, 213, 255, 255, 245, 191, 255,253, 127, 255, 255, 99, 255, 255, 217, 55, 255, 62, 31, 254, 127, 252, 123, 39,255, 127, 175, 143, 247, 254, 101, 204, 249, 192, 73, 16, 67, 20, 114, 75, 55, 103, 255, 242, 127, 255, 191, 239, 255, 236, 253, 189, 218, 59, 244, 234, 249, 120, 124, 254, 159, 93, 123, 60, 124, 190, 223, 125, 180, 121, 254, 63, 62, 159, 175, 223, 252, 255, 255, 246, 191, 239, 255, 187, 191, 255, 228, 239, 85, 43, 225, 85, 108, 245, 246, 178, 219, 155, 127, 243, 12, 93, 199, 151, 62, 157, 125, 255, 255, 191, 249, 255, 254, 255, 223, 255, 255, 111, 255, 255, 220, 255, 255, 247, 127, 255, 253, 239, 255, 255, 127, 255, 255, 224, 255, 255, 248, 127, 255, 254, 47, 255, 255, 143, 255, 255, 228, 255, 255, 249, 127, 255, 254, 111, 255, 255, 159, 255, 255, 232, 255, 255, 250, 127, 255, 254, 175, 255, 255, 175, 255, 255, 236, 255, 255, 251, 127, 255, 254, 239, 255, 255, 191, 255, 255, 240, 255, 255, 252, 127, 255, 255, 47, 255, 255, 207, 255, 255, 244, 255, 255, 253, 127, 255, 255, 111, 255, 255, 223, 255, 255, 248, 255, 255, 254, 127, 255, 255, 175, 255, 255, 239, 255, 255, 252, 255, 255, 255, 127, 255, 255, 239, 255, 255, 255, 255, 255, 1, 255, 255, 129, 255, 255, 193, 127, 255, 224, 255, 255, 240, 159, 255, 248, 95, 255, 252, 55, 255, 254, 31, 255, 255, 17, 255, 255, 137, 255, 255, 197,127, 255, 226, 255, 255, 241, 159, 255, 248, 223, 255, 252, 119, 255, 254, 63, 255, 255, 33, 255, 255, 145, 255, 255, 201, 127, 255, 228, 255, 255, 242, 159, 255, 249, 95, 255, 252, 183, 255, 254, 95, 255, 255, 49, 255, 255, 153, 255, 255,205, 127, 255, 230, 255, 255, 243, 159, 255, 249, 223, 255, 252, 247, 255, 254,127, 255, 255, 65, 255, 255, 161, 255, 255, 209, 127, 255, 232, 255, 255, 244, 159, 255, 250, 95, 255, 253, 55, 255, 254, 159, 255, 255, 81, 255, 255, 169, 255, 255, 213, 127, 255, 234, 255, 255, 245, 159, 255, 250, 223, 255, 253, 119, 255, 254, 191, 255, 255, 97, 255, 255, 177, 255, 255, 217, 127, 255, 236, 255, 255,246, 159, 255, 251, 95, 255, 253, 183, 255, 254, 223, 255, 255, 113, 255, 255, 185, 255, 255, 221, 127, 255, 238, 255, 255, 247, 159, 255, 251, 223, 255, 253, 247, 255, 254, 255, 255, 255, 129, 255, 255, 193, 255, 255, 225, 127, 255, 240, 255, 255, 248, 159, 255, 252, 95, 255, 254, 55, 255, 255, 31, 255, 255, 145, 255, 255, 201, 255, 255, 229, 127, 255, 242, 255, 255, 249, 159, 255, 252, 223, 255, 254, 119, 255, 255, 63, 255, 255, 161, 255, 255, 209, 255, 255, 233, 127, 255,244, 255, 255, 250, 159, 255, 253, 95, 255, 254, 183, 255, 255, 95, 255, 255, 177, 255, 255, 217, 255, 255, 237, 127, 255, 246, 255];

    let decoded_bytes = decoder.decode(huffman_codes).unwrap();
    let ascii_sequence = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];

    assert!(decoded_bytes == ascii_sequence);
}